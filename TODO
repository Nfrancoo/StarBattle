import pygame
from pygame import mixer
from personaje_2 import Personaje
from enemigo_2 import Enemigo
from plataforma import Plataforma

mixer.init()
pygame.init()
# Función para pintar el fondo
def pintar_fondo():
    global PANTALLA
    fondo_escalado = pygame.transform.scale(fondo, (pantalla_width, pantalla_height))
    PANTALLA.blit(fondo_escalado, (0, 0))

# Función para pintar la barra de vida en pantalla
def pintar_vida_barra(vida, x, y):
    ratio = vida / 100
    pygame.draw.rect(PANTALLA, 'White', (x - 2, y - 2, 404, 34))
    pygame.draw.rect(PANTALLA, 'Red', (x, y, 400, 30))
    pygame.draw.rect(PANTALLA, 'Yellow', (x, y, 400 * ratio, 30))

#function for drawing text
def draw_text(text, font, text_col, x, y):
  img = font.render(text, True, text_col)
  PANTALLA.blit(img, (x, y))

#create game window
pantalla_width = 1000
pantalla_height = 600

PANTALLA = pygame.display.set_mode((pantalla_width, pantalla_height))
pygame.display.set_caption('StarBattle')


# Reloj
reloj = pygame.time.Clock()
FPS = 60


#define game variables
intro_count = 3
last_count_update = pygame.time.get_ticks()
score = [0, 0]#player scores. [P1, P2]
round_over = False
ROUND_OVER_COOLDOWN = 2000

# Definir variables de imagen
WARRIOR_SIZE = 162
WARRIOR_SCALE = 4
WARRIOR_OFFSET = [72, 56]
WARRIOR_DATA = [WARRIOR_SIZE, WARRIOR_SCALE, WARRIOR_OFFSET]
WIZARD_SIZE = 250
WIZARD_SCALE = 3
WIZARD_OFFSET = [112, 107]
WIZARD_DATA = [WIZARD_SIZE, WIZARD_SCALE, WIZARD_OFFSET]

#load music and sounds
pygame.mixer.music.load("audio\music.mp3")
pygame.mixer.music.set_volume(0.5)
pygame.mixer.music.play(-1, 0.0, 5000)
sword_fx = pygame.mixer.Sound("audio\sword.wav")
sword_fx.set_volume(0.5)
magic_fx = pygame.mixer.Sound("audio\magic.wav")
magic_fx.set_volume(0.75)

#load background image
fondo = pygame.image.load('imagenes/69.webp')

#load spritesheets
warrior_sheet = pygame.image.load('warrior\Sprites\warrior.png')
wizard_sheet = pygame.image.load('wizard\Sprites\wizard.png')

#load vicory image
victory_img = pygame.image.load("imagenes/victory.png")

#define number of steps in each animation
WARRIOR_ANIMACION_PASOS = [10, 8, 1, 7, 7, 3, 7]
WIZARD_ANIMACION_PASOS= [8, 8, 1, 8, 8, 3, 7]

#define font
count_font = pygame.font.Font("fonts/turok.ttf", 80)
score_font = pygame.font.Font("fonts/turok.ttf", 30)


#create two instances of fighters
personaje_1 = Personaje(1, 200, 310, False, WARRIOR_DATA, warrior_sheet, WARRIOR_ANIMACION_PASOS, sword_fx)
personaje_2 = Enemigo(2, 700, 310, True, WIZARD_DATA, wizard_sheet, WIZARD_ANIMACION_PASOS, magic_fx)


plataformas = [
    #Plataforma(200, 210, 600, 20, 'Gray'),
    # Plataforma(100, 400, 200, 10, 'Gray'),
    # Plataforma(700, 400, 200, 10, 'Gray')
]
#game loop
run = True
while run:

  reloj.tick(FPS)

  #draw background
  pintar_fondo()

  #show player stats
  pintar_vida_barra(personaje_1.vida, 20, 20)
  pintar_vida_barra(personaje_2.vida, 580, 20)
  draw_text("P1: " + str(score[0]), score_font, 'Red', 20, 60)
  draw_text("P2: " + str(score[1]), score_font, 'Red', 580, 60)

  #update countdown
  if intro_count <= 0:
    #move fighters
    personaje_1.movimiento(pantalla_width, pantalla_height, PANTALLA, personaje_2, round_over,plataformas)
    personaje_2.movimiento(pantalla_width, pantalla_height, PANTALLA, personaje_1, round_over,plataformas)

    distancia = personaje_1.rect.x - personaje_2.rect.x
    if abs(distancia) <= 3 * personaje_2.DISTANCIA_DE_ATAQUE:
        personaje_2.ataque(personaje_1)

  else:
    #display count timer
    draw_text(str(intro_count), count_font, 'Red', pantalla_width / 2, pantalla_height / 3)
    #update count timer
    if (pygame.time.get_ticks() - last_count_update) >= 1000:
      intro_count -= 1
      last_count_update = pygame.time.get_ticks()

  #update fighters
  personaje_1.update()
  personaje_2.update()

  #draw fighters
  personaje_1.draw(PANTALLA)
  personaje_2.draw(PANTALLA)


  #check for player defeat
  if round_over == False:
    if personaje_1.vivo == False:
      score[1] += 1
      round_over = True
      round_over_time = pygame.time.get_ticks()
    elif personaje_2.vivo == False:
      score[0] += 1
      round_over = True
      round_over_time = pygame.time.get_ticks()
  else:
    #display victory image
    PANTALLA.blit(victory_img, (360, 150))
    if pygame.time.get_ticks() - round_over_time > ROUND_OVER_COOLDOWN:
      round_over = False
      intro_count = 3
      personaje_1 = Personaje(1, 200, 310, False, WARRIOR_DATA, warrior_sheet, WARRIOR_ANIMACION_PASOS, sword_fx)
      personaje_2 = Enemigo(2, 700, 310, True, WIZARD_DATA, wizard_sheet, WIZARD_ANIMACION_PASOS, magic_fx)


  #event handler
  for event in pygame.event.get():
    if event.type == pygame.QUIT:
      run = False

  for plataforma in plataformas:
    plataforma.pintar(PANTALLA)


  #update display
  pygame.display.update()

#exit pygame
pygame.quit()


import pygame

class Enemigo():
    def __init__(self, player, x, y, flip, data, sprite_sheet, pasos_animacion, sound):
        self.size = data[0]
        self.imagen_escalada = data[1]
        self.desplazamiento = data[2]
        self.flip = flip
        self.lista_animaciones = self.cargar_imagenes(sprite_sheet, pasos_animacion)
        self.accion = 0  # 0:idle, 1:run, 2:salto, 3:attack1, 4:attack2, 5:hit, 6:death
        self.frame_index = 0
        self.imagen = self.lista_animaciones[self.accion][self.frame_index]
        self.update_time = pygame.time.get_ticks()
        self.rect = pygame.Rect(x, y, 80, 180)
        self.velocidad_y = 0
        self.corriendo = False
        self.salto = False
        self.golpeando = False
        self.tipo_ataque = 0
        self.cooldown_ataque = 0
        self.sonido_ataque = sound
        self.hit = False
        self.vida = 100
        self.vivo = True
        self.puede_saltar = True
        self.DISTANCIA_DE_ATAQUE = 1200

    def cargar_imagenes(self, sprite_sheet, pasos_animacion):
        lista_animaciones = []
        for y, animacion in enumerate(pasos_animacion):
            temp_img_list = []
            for x in range(animacion):
                temp_img = sprite_sheet.subsurface(x * self.size, y * self.size, self.size, self.size)
                temp_img_list.append(pygame.transform.scale(temp_img, (self.size * self.imagen_escalada, self.size * self.imagen_escalada)))
            lista_animaciones.append(temp_img_list)
        return lista_animaciones

    def movimiento(self, screen_width, screen_height, surface, target, round_over, plataformas):
        VELOCIDAD = 10
        GRAVEDAD = 2
        dx = 0
        dy = 0
        self.corriendo = False
        self.tipo_ataque = 0
        DISTANCIA_DE_ATAQUE = 195
        distancia = target.rect.x - self.rect.x
        img = pygame.transform.flip(self.imagen, self.flip, False)

        if self.golpeando == False and self.vivo == True and round_over == False:
            if abs(distancia) > DISTANCIA_DE_ATAQUE:
                dx = VELOCIDAD * (distancia / abs(distancia))
                self.corriendo = True

            # Aplicar gravedad
            self.velocidad_y += GRAVEDAD
            dy += self.velocidad_y

            # Asegurar que el enemigo permanezca en la pantalla
            if self.rect.left + dx < 0:
                dx = -self.rect.left
            if self.rect.right + dx > screen_width:
                dx = screen_width - self.rect.right
            if self.rect.bottom + dy > screen_height - 110:
                self.velocidad_y = 0
                self.salto = False
                dy = screen_height - 110 - self.rect.bottom
                self.puede_saltar = True  # Permitir saltar nuevamente

            if target.rect.centerx > self.rect.centerx:
                self.flip = False
            else:
                self.flip = True

            if self.salto and self.rect.y > -30:
                surface.blit(img, (self.rect.x - (self.desplazamiento[0] * self.imagen_escalada),
                   self.rect.y - self.desplazamiento[1] * self.imagen_escalada - self.velocidad_y))
            # Aplicar movimiento en las coordenadas del rectángulo
            self.rect.x += dx
            self.rect.y += dy

            # Lógica de salto
            if target.salto and self.velocidad_y == 0 and self.puede_saltar:
                self.velocidad_y = -30
                self.salto = True
                self.puede_saltar = False  # No permitir saltar nuevamente

            for plataforma in plataformas:
                if self.rect.colliderect(plataforma.rectangulo):
                    # Si está colisionando, detener el movimiento vertical y ajustar la posición
                    if self.velocidad_y > 0:
                        self.rect.bottom = plataforma.rectangulo.top
                        self.velocidad_y = 0
                        self.salto = False
                        self.puede_saltar = True  # Permitir saltar nuevamente
                    elif self.velocidad_y < 0:
                        self.rect.top = plataforma.rectangulo.bottom
                        self.velocidad_y = 0
                        
            # Aplicar cooldown al ataque
            if self.cooldown_ataque > 0:
                self.cooldown_ataque -= 1

            if self.flip:
                self.tipo_ataque = 1
            else:
                self.tipo_ataque = 2

    def ataque(self, target):
        if self.salto:
            return  # Si el enemigo está saltando, no puede atacar

        if self.rect.colliderect(target.rect):  # Verificar colisión general
            if self.cooldown_ataque == 0:
                self.golpeando = True
                attack_rect = pygame.Rect(self.rect.centerx - (2 * self.rect.width * self.flip),
                                        self.rect.y, 2 * self.rect.width, self.rect.height)
                if attack_rect.colliderect(target.rect):  # Verificar colisión de ataque específica
                    target.vida -= 10
                    target.hit = True
                self.cooldown_ataque = 50  # Set cooldown time to 50 frames

        self.update()

    def update(self):
        if self.vida <= 0:
            self.vida = 0
            self.vivo = False
            self.update_accion(6)
        if self.hit:
            self.update_accion(5)
        if self.golpeando:
            if self.tipo_ataque == 1:
                self.update_accion(3)
            elif self.tipo_ataque == 2:
                self.update_accion(4)
        elif self.salto:
            self.update_accion(2)
        elif self.corriendo:
            self.update_accion(1)
        else:
            self.update_accion(0)

        animation_cooldown = 50
        self.imagen = self.lista_animaciones[self.accion][self.frame_index]
        if pygame.time.get_ticks() - self.update_time > animation_cooldown:
            self.frame_index += 1
            self.update_time = pygame.time.get_ticks()
        if self.cooldown_ataque > 0:
            self.cooldown_ataque -= 1

        if self.frame_index >= len(self.lista_animaciones[self.accion]):
            self.frame_index = 0
            if self.accion == 3 or self.accion == 4:
                self.golpeando = False
                self.cooldown_ataque = 20
            if self.accion == 5:
                self.hit = False
                self.golpeando = False
                self.cooldown_ataque = 20

    def draw(self, surface):
        img = pygame.transform.flip(self.imagen, self.flip, False)
        surface.blit(img, (self.rect.x - self.desplazamiento[0] * self.imagen_escalada,
                   self.rect.y - self.desplazamiento[1] * self.imagen_escalada))


    def update_accion(self, new_accion):
        if new_accion != self.accion:
            self.accion = new_accion
            self.frame_index = 0
            self.update_time = pygame.time.get_ticks()
import pygame

class Personaje():
  def __init__(self, player, x, y, flip, data, sprite_sheet, animacion_pasos, sound):
    self.player = player
    self.tamaño = data[0]
    self.imagen_escalada = data[1]
    self.desplazamiento = data[2]
    self.flip = flip
    self.lista_animaciones = self.cargar_imagenes(sprite_sheet, animacion_pasos)
    self.accion = 0#0:idle #1:run #2:salto #3:attack1 #4: attack2 #5:hit #6:death
    self.frame_index = 0
    self.imagen = self.lista_animaciones[self.accion][self.frame_index]
    self.update_time = pygame.time.get_ticks()
    self.rect = pygame.Rect((x, y, 80, 180))
    self.velocidad_y = 0
    self.corriendo = False
    self.salto = False
    self.atacando = False
    self.tipo_ataque = 0
    self.cooldown_ataque = 0
    self.sonido_ataque = sound
    self.hit = False
    self.vida = 10000
    self.vivo = True


  def cargar_imagenes(self, sprite_sheet, animacion_pasos):
    #extract images from spritesheet
    lista_animaciones = []
    for y, animation in enumerate(animacion_pasos):
      temp_img_list = []
      for x in range(animation):
        temp_img = sprite_sheet.subsurface(x * self.tamaño, y * self.tamaño, self.tamaño, self.tamaño)
        temp_img_list.append(pygame.transform.scale(temp_img, (self.tamaño * self.imagen_escalada, self.tamaño * self.imagen_escalada)))
      lista_animaciones.append(temp_img_list)
    return lista_animaciones


  def movimiento(self, screen_width, screen_height, surface, target, round_over,plataformas):
    VELOCIDAD = 10
    GRAVEDAD = 2
    dx = 0
    dy = 0
    self.corriendo = False
    self.tipo_ataque = 0

    #get keypresses
    key = pygame.key.get_pressed()

    #can only perform other accions if not currently atacando
    if self.atacando == False and self.vivo == True and round_over == False:
      #check player 1 controls
      if self.player == 1:
        #movement
        if key[pygame.K_a]:
          dx = -VELOCIDAD
          self.corriendo = True
        if key[pygame.K_d]:
          dx = VELOCIDAD
          self.corriendo = True
        #salto
        if key[pygame.K_w] and self.salto == False:
          self.velocidad_y = -30
          self.salto = True
        #attack
        if key[pygame.K_r] or key[pygame.K_t]:
          self.attack(target)
          #determine which attack type was used
          if key[pygame.K_r]:
            self.tipo_ataque = 1
          if key[pygame.K_t]:
            self.tipo_ataque = 2

    #apply gravity
    self.velocidad_y += GRAVEDAD
    dy += self.velocidad_y

    #ensure player stays on screen
    if self.rect.left + dx < 0:
      dx = -self.rect.left
    if self.rect.right + dx > screen_width:
      dx = screen_width - self.rect.right
    if self.rect.bottom + dy > screen_height - 110:
      self.velocidad_y = 0
      self.salto = False
      dy = screen_height - 110 - self.rect.bottom

    #ensure players face each other
    if target.rect.centerx > self.rect.centerx:
      self.flip = False
    else:
      self.flip = True

    #apply attack cooldown
    if self.cooldown_ataque > 0:
      self.cooldown_ataque -= 1


    for plataforma in plataformas:
            if self.rect.colliderect(plataforma.rectangulo):
                # Si está colisionando, detener el movimiento vertical y ajustar la posición
                if self.velocidad_y > 0:
                    self.rect.bottom = plataforma.rectangulo.top
                    self.velocidad_y = 0
                    self.salto = False
                elif self.velocidad_y < 0:
                    self.rect.top = plataforma.rectangulo.bottom
                    self.velocidad_y = 0

    #update player position
    self.rect.x += dx
    self.rect.y += dy


  #handle animation updates
  def update(self):
    #check what accion the player is performing
    if self.vida <= 0:
      self.vida = 0
      self.vivo = False
      self.update_accion(6)#6:death
    elif self.hit == True:
      self.update_accion(5)#5:hit
    elif self.atacando == True:
      if self.tipo_ataque == 1:
        self.update_accion(3)
      elif self.tipo_ataque == 2:
        self.update_accion(4)
    elif self.salto == True:
      self.update_accion(2)#2:salto
    elif self.corriendo == True:
      self.update_accion(1)#1:run
    else:
      self.update_accion(0)#0:idle

    animation_cooldown = 50
    #update imagen
    self.imagen = self.lista_animaciones[self.accion][self.frame_index]
    #check if enough time has passed since the last update
    if pygame.time.get_ticks() - self.update_time > animation_cooldown:
      self.frame_index += 1
      self.update_time = pygame.time.get_ticks()
    #check if the animation has finished
    if self.frame_index >= len(self.lista_animaciones[self.accion]):
      #if the player is dead then end the animation
      if self.vivo == False:
        self.frame_index = len(self.lista_animaciones[self.accion]) - 1
      else:
        self.frame_index = 0
        #check if an attack was executed
        if self.accion == 3 or self.accion == 4:
          self.atacando = False
          self.cooldown_ataque = 20
        #check if damage was taken
        if self.accion == 5:
          self.hit = False
          #if the player was in the middle of an attack, then the attack is stopped
          self.atacando = False
          self.cooldown_ataque = 20


  def attack(self, target):
    if self.cooldown_ataque == 0:
      #execute attack
      self.atacando = True     
      self.sonido_ataque.play()
      attacking_rect = pygame.Rect(self.rect.centerx - (2 * self.rect.width * self.flip), self.rect.y, 2 * self.rect.width, self.rect.height)
      if attacking_rect.colliderect(target.rect):
        target.vida -= 10
        target.hit = True


  def update_accion(self, new_accion):
    #check if the new accion is different to the previous one
    if new_accion != self.accion:
      self.accion = new_accion
      #update the animation settings
      self.frame_index = 0
      self.update_time = pygame.time.get_ticks()

  def draw(self, surface):
    img = pygame.transform.flip(self.imagen, self.flip, False)
    surface.blit(img, (self.rect.x - (self.desplazamiento[0] * self.imagen_escalada), self.rect.y - (self.desplazamiento[1] * self.imagen_escalada)))